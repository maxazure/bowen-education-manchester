# -*- coding: utf-8 -*-
"""Frontend Routes

All public-facing routes for visitors
"""

import logging

from fastapi import APIRouter, Depends, Form, HTTPException, Request
from fastapi.responses import HTMLResponse, JSONResponse, RedirectResponse
from fastapi.templating import Jinja2Templates
from jinja2.exceptions import TemplateNotFound
from pydantic import BaseModel, EmailStr, ValidationError
from sqlalchemy.orm import Session

from app.config import settings
from app.database import get_db
from app.models import ColumnType, SiteColumn
from app.models.contact import ContactMessage
from app.schemas.requests import ContactFormRequest
from app.services import post_service, product_service, site_service
from app.services import layout_service as layout_render_service
from app.utils.template_helpers import (
    get_navigation,
    post_list,
    product_list,
    site_info,
)
from app.routes.frontend_i18n import get_template_engine, get_lang_from_path

logger = logging.getLogger("docms")

router = APIRouter()
# 默认使用中文模板目录（向后兼容）
templates = Jinja2Templates(directory=str(settings.template_dir / "zh"))


class ContactForm(BaseModel):
    """Contact form data model"""

    name: str
    email: EmailStr
    phone: str = ""
    subject: str
    message: str


# Add template helper functions to Jinja2 globals
templates.env.globals.update(
    {
        "product_list": product_list,
        "post_list": post_list,
        "site_info": site_info,
        "get_navigation": get_navigation,
    }
)


def get_base_context(request: Request, db: Session, lang: str = "zh") -> dict:
    """
    Get base template context

    Args:
        request: FastAPI request object
        db: Database session
        lang: Language code ('zh' or 'en')

    Returns:
        Dictionary with base context variables
    """
    site_settings = site_service.get_all_site_settings(db)
    return {
        "request": request,
        "db": db,
        "site_settings": site_settings,
        "site": site_settings,  # Alias for template compatibility
        "navigation": site_service.get_navigation(db, "header"),  # Header menu only
        "footer_navigation": site_service.get_navigation(db, "footer"),  # Footer menu only
        "lang": lang,  # 当前语言
        "current_lang": lang,  # 别名，用于模板
    }


@router.get("/", response_class=HTMLResponse)
@router.get("/zh/", response_class=HTMLResponse)
async def homepage(request: Request, db: Session = Depends(get_db)):
    """Homepage (Chinese/Mixed)"""
    lang = "zh"
    context = get_base_context(request, db, lang=lang)
    templates_engine = get_template_engine(lang)

    # 优先使用已发布的布局进行渲染
    from app.models.layout import LayoutScope
    published_layout = layout_render_service.get_published_layout(db, LayoutScope.HOME)
    if published_layout:
        html = layout_render_service.render_layout_html(db, published_layout)
        return templates_engine.TemplateResponse("layout_page.html", {"request": request, **context, "layout_html": html})

    # Get homepage column
    home_column = site_service.get_column_by_slug(db, "home")
    if home_column and home_column.column_type == ColumnType.SINGLE_PAGE:
        page = site_service.get_single_page(db, home_column.id)
        context["page"] = page

    # Get featured event for hero carousel (最新推荐的活动文章)
    featured_event = post_service.get_posts(db, is_recommended=True, limit=1)
    context["featured_event"] = featured_event[0] if featured_event else None

    # Get latest 6 posts for News & Events section
    latest_posts = post_service.get_posts(db, limit=6, status="published")
    context["latest_posts"] = latest_posts

    # Get recommended products (for other sections if needed)
    context["featured_products"] = product_service.get_products(
        db, is_recommended=True, limit=6
    )

    return templates_engine.TemplateResponse("home.html", context)


@router.get("/en/", response_class=HTMLResponse)
async def homepage_en(request: Request, db: Session = Depends(get_db)):
    """Homepage (English only)"""
    lang = "en"
    context = get_base_context(request, db, lang=lang)
    templates_engine = get_template_engine(lang)

    # 优先使用已发布的布局进行渲染
    from app.models.layout import LayoutScope
    published_layout = layout_render_service.get_published_layout(db, LayoutScope.HOME)
    if published_layout:
        html = layout_render_service.render_layout_html(db, published_layout)
        return templates_engine.TemplateResponse("layout_page.html", {"request": request, **context, "layout_html": html})

    # Get homepage column
    home_column = site_service.get_column_by_slug(db, "home")
    if home_column and home_column.column_type == ColumnType.SINGLE_PAGE:
        page = site_service.get_single_page(db, home_column.id)
        context["page"] = page

    # Get featured event for hero carousel
    featured_event = post_service.get_posts(db, is_recommended=True, limit=1)
    context["featured_event"] = featured_event[0] if featured_event else None

    # Get latest 6 posts for News & Events section
    latest_posts = post_service.get_posts(db, limit=6, status="published")
    context["latest_posts"] = latest_posts

    # Get recommended products
    context["featured_products"] = product_service.get_products(
        db, is_recommended=True, limit=6
    )

    return templates_engine.TemplateResponse("home.html", context)


@router.get("/en/{column_slug:path}", response_class=HTMLResponse)
async def column_page_en(
    column_slug: str, request: Request, db: Session = Depends(get_db)
):
    """English version of column pages"""
    # 调用主要的 column_page_generic 函数，传入 lang="en"
    return await column_page_generic(column_slug, request, db, lang="en")


@router.get("/{column_slug}", response_class=HTMLResponse)
async def column_page(
    column_slug: str, request: Request, db: Session = Depends(get_db)
):
    """Column page (product list, post list, or single page) - Chinese/Mixed version"""
    return await column_page_generic(column_slug, request, db, lang="zh")


async def column_page_generic(
    column_slug: str, request: Request, db: Session, lang: str = "zh"
):
    """Generic column page handler with language support"""
    # Exclude admin paths - they should be handled by admin router
    if column_slug.startswith("admin"):
        raise HTTPException(status_code=404, detail="Page not found")

    column = site_service.get_column_by_slug(db, column_slug)

    if not column:
        raise HTTPException(status_code=404, detail="Page not found")

    context = get_base_context(request, db, lang=lang)
    templates_engine = get_template_engine(lang)
    context["column"] = column

    # Universal layout priority: if a published layout exists for this column, render it
    from app.models.layout import LayoutScope
    published_layout_for_column = layout_render_service.get_published_layout(db, LayoutScope.COLUMN, scope_id=column.id)
    if published_layout_for_column:
        html = layout_render_service.render_layout_html(db, published_layout_for_column)
        return templates.TemplateResponse("layout_page.html", {"request": request, **context, "layout_html": html})

    # Add parent column and sibling columns for sidebar navigation
    if column.parent_id:
        parent_column = db.query(SiteColumn).filter(
            SiteColumn.id == column.parent_id
        ).first()
        context["parent_column"] = parent_column

        # Get sibling columns (including current column)
        sibling_columns = site_service.get_child_columns(db, column.parent_id)
        context["sibling_columns"] = sibling_columns

    # Handle different column types
    if column.column_type == ColumnType.SINGLE_PAGE:
        page = site_service.get_single_page(db, column.id)
        if not page:
            raise HTTPException(status_code=404, detail="Page not found")

        context["page"] = page

        # Check for custom template (e.g., about.html, contact.html)
        try:
            return templates.TemplateResponse(f"{column_slug}.html", context)
        except TemplateNotFound:
            logger.debug(
                f"Custom template {column_slug}.html not found, using default single_page.html"
            )
            return templates.TemplateResponse("single_page.html", context)

    elif column.column_type == ColumnType.PRODUCT:
        # Get category filter from query params
        category_id = request.query_params.get("category")
        if category_id:
            try:
                category_id = int(category_id)
            except (ValueError, TypeError):
                category_id = None

        categories = product_service.get_product_categories(db, column.id)
        products = product_service.get_products(
            db, column_id=column.id, category_id=category_id
        )

        context["categories"] = categories
        context["products"] = products
        context["current_category_id"] = category_id
        context["total"] = product_service.get_product_count(
            db, column_id=column.id, category_id=category_id
        )

        # Check for custom template (e.g., products.html)
        try:
            return templates.TemplateResponse(f"{column_slug}.html", context)
        except TemplateNotFound:
            logger.debug(
                f"Custom template {column_slug}.html not found, using default product_list.html"
            )
            return templates.TemplateResponse("product_list.html", context)

    elif column.column_type == ColumnType.POST:
        # Get category filter from query params
        category_id = request.query_params.get("category")
        if category_id:
            try:
                category_id = int(category_id)
            except (ValueError, TypeError):
                category_id = None

        categories = post_service.get_post_categories(db, column.id)
        # For guestbook, only show approved messages
        is_approved_filter = True if column_slug == "guestbook" else None
        posts = post_service.get_posts(db, column_id=column.id, category_id=category_id, is_approved=is_approved_filter)

        # Get additional data for sidebar
        popular_posts = post_service.get_popular_posts(db, column.id, limit=5)
        category_stats = post_service.get_category_stats(db, column.id)
        popular_tags = post_service.get_popular_tags(db, column.id, limit=20)

        context["categories"] = categories
        context["posts"] = posts
        context["current_category_id"] = category_id
        context["total"] = post_service.get_post_count(
            db, column_id=column.id, category_id=category_id, is_approved=is_approved_filter
        )
        context["popular_posts"] = popular_posts
        context["category_stats"] = category_stats
        context["popular_tags"] = popular_tags

        # Add parent column and sibling columns for sidebar navigation (for school curriculum)
        if column.parent_id:
            parent_column = db.query(SiteColumn).filter(
                SiteColumn.id == column.parent_id
            ).first()
            context["parent_column"] = parent_column

            # Get sibling columns (including current column)
            sibling_columns = site_service.get_child_columns(db, column.parent_id)
            context["sibling_columns"] = sibling_columns

        # Special template handling for pages with sidebar navigation
        if column_slug == "school-curriculum":
            return templates.TemplateResponse("post_list_with_sidebar.html", context)
        elif column_slug in ["chess-events", "chess-news", "news", "badminton-events"]:
            return templates.TemplateResponse("post_list_universal.html", context)

        # Check for custom template
        try:
            return templates.TemplateResponse(f"{column_slug}.html", context)
        except TemplateNotFound:
            logger.debug(
                f"Custom template {column_slug}.html not found, using default post_list.html"
            )
            return templates.TemplateResponse("post_list.html", context)

    elif column.column_type == ColumnType.GALLERY:
        # Gallery column type - display photos/media files
        from app.services.gallery_service import GalleryService

        gallery_service = GalleryService(db)

        # Get gallery by slug
        gallery = gallery_service.get_gallery_by_slug(column_slug)

        if gallery:
            # Get images for this gallery
            images = gallery_service.get_gallery_images(gallery.id)

            # Increment view count
            gallery_service.increment_view_count(gallery.id)

            # Extract media files from images
            media_files = [img.media for img in images if img.media and img.is_visible]

            context["gallery"] = gallery
            context["images"] = images
            context["media_files"] = media_files
        else:
            context["media_files"] = []

        return templates.TemplateResponse("gallery.html", context)

    elif column.column_type == ColumnType.CUSTOM:
        # 优先使用自定义栏目的已发布布局进行渲染
        # 已在通用检查处处理，此处继续旧逻辑

        # For custom columns like Home, try to render custom template
        # If home slug, redirect to homepage
        if column_slug == "home":
            from fastapi.responses import RedirectResponse

            return RedirectResponse(url="/", status_code=302)

        # Special handling for gallery pages
        if column_slug.endswith("-gallery") or column_slug == "gallery":
            from app.services.gallery_service import GalleryService

            gallery_service = GalleryService(db)

            # If it's the main gallery page, show all galleries
            if column_slug == "gallery":
                from app.models.gallery import Gallery
                all_galleries = db.query(Gallery).filter(Gallery.is_public == True).order_by(Gallery.sort_order).all()
                context["galleries"] = all_galleries
                context["page"] = column

                # Use gallery_list template for gallery overview
                try:
                    return templates.TemplateResponse("gallery_list.html", context)
                except TemplateNotFound:
                    logger.warning("gallery_list.html template not found, falling back to single_page.html")
                    try:
                        return templates.TemplateResponse("single_page.html", context)
                    except TemplateNotFound:
                        raise HTTPException(status_code=404, detail="Template not found")
            else:
                # For specific gallery pages like chess-gallery, badminton-gallery
                gallery = gallery_service.get_gallery_by_slug(column_slug)

                if gallery:
                    # Get images for this gallery
                    images = gallery_service.get_gallery_images(gallery.id)

                    # Increment view count
                    gallery_service.increment_view_count(gallery.id)

                    context["gallery"] = gallery
                    context["images"] = images

                    try:
                        return templates.TemplateResponse("gallery.html", context)
                    except TemplateNotFound:
                        logger.warning("gallery.html template not found")
                        raise HTTPException(status_code=404, detail="Gallery template not found")

        # Special handling for events page (before overview check)
        if column_slug == "events":
            from app.services import event_service
            # Get upcoming events
            events_service = event_service.EventService(db)
            upcoming_events = events_service.get_upcoming_events(limit=12)
            context["events"] = upcoming_events
            # Try custom events template
            try:
                return templates.TemplateResponse("events.html", context)
            except TemplateNotFound:
                logger.warning("events.html template not found")
                # Continue to default handling

        # Special handling for main column pages with custom templates (school, chess, badminton, etc.)
        # These pages have child columns but use custom templates instead of overview.html
        main_column_pages = ["school", "chess", "badminton", "programmes", "contact"]
        if column_slug in main_column_pages:
            try:
                return templates.TemplateResponse(f"{column_slug}.html", context)
            except TemplateNotFound:
                logger.warning(f"Custom template {column_slug}.html not found for main column page")
                # Continue to default handling

        # Check if this is an overview page (has child columns)
        child_columns = site_service.get_child_columns(db, column.id)
        if child_columns:
            # This is an overview/composite page - render with sections
            sections = site_service.get_overview_sections(db, column.id)
            context["sections"] = sections
            return templates.TemplateResponse("overview.html", context)

        # For other custom columns without children, try custom template
        try:
            return templates.TemplateResponse(f"{column_slug}.html", context)
        except TemplateNotFound:
            logger.warning(
                f"Custom template {column_slug}.html not found for custom column"
            )
            raise HTTPException(status_code=404, detail="Page not found")

    raise HTTPException(status_code=404, detail="Page not found")


@router.get("/{column_slug}/{item_slug}", response_class=HTMLResponse)
async def item_detail_page_short(
    column_slug: str, item_slug: str, request: Request, db: Session = Depends(get_db)
):
    """Short URL format for post and product detail pages (e.g., /news/{slug})"""
    # Exclude admin paths - they should be handled by admin router
    if column_slug.startswith("admin"):
        raise HTTPException(status_code=404, detail="Page not found")

    column = site_service.get_column_by_slug(db, column_slug)

    if not column:
        raise HTTPException(status_code=404, detail="Page not found")

    # Only handle POST and PRODUCT types with this short URL format
    if column.column_type not in [ColumnType.POST, ColumnType.PRODUCT]:
        raise HTTPException(status_code=404, detail="Page not found")

    context = get_base_context(request, db)
    context["column"] = column

    # Handle different column types
    if column.column_type == ColumnType.PRODUCT:
        product = product_service.get_product_by_slug(db, item_slug)

        if not product:
            raise HTTPException(status_code=404, detail="Product not found")

        context["product"] = product

        # Get related products
        if product.categories:
            context["related_products"] = product_service.get_products(
                db, category_id=product.categories[0].id, limit=4
            )

        return templates.TemplateResponse("product_detail.html", context)

    elif column.column_type == ColumnType.POST:
        post = post_service.get_post_by_slug(db, item_slug)

        if not post:
            raise HTTPException(status_code=404, detail="Post not found")

        context["post"] = post

        # Get related posts
        if post.categories:
            context["related_posts"] = post_service.get_posts(
                db, category_id=post.categories[0].id, limit=3
            )

        # Add parent column and sibling columns for sidebar navigation
        if column.parent_id:
            parent_column = db.query(SiteColumn).filter(
                SiteColumn.id == column.parent_id
            ).first()
            context["parent_column"] = parent_column

            # Get sibling columns (including current column)
            sibling_columns = site_service.get_child_columns(db, column.parent_id)
            context["sibling_columns"] = sibling_columns

        return templates.TemplateResponse("post_detail.html", context)


@router.get("/{column_slug}/detail/{item_slug}", response_class=HTMLResponse)
async def item_detail_page(
    column_slug: str, item_slug: str, request: Request, db: Session = Depends(get_db)
):
    """Universal item detail page for products and posts (legacy URL format)"""
    # Exclude admin paths - they should be handled by admin router
    if column_slug.startswith("admin"):
        raise HTTPException(status_code=404, detail="Page not found")

    column = site_service.get_column_by_slug(db, column_slug)

    if not column:
        raise HTTPException(status_code=404, detail="Page not found")

    context = get_base_context(request, db)
    context["column"] = column

    # Handle different column types
    if column.column_type == ColumnType.PRODUCT:
        product = product_service.get_product_by_slug(db, item_slug)

        if not product:
            raise HTTPException(status_code=404, detail="Product not found")

        context["product"] = product

        # Get related products
        if product.categories:
            context["related_products"] = product_service.get_products(
                db, category_id=product.categories[0].id, limit=4
            )

        return templates.TemplateResponse("product_detail.html", context)

    elif column.column_type == ColumnType.POST:
        post = post_service.get_post_by_slug(db, item_slug)

        if not post:
            raise HTTPException(status_code=404, detail="Post not found")

        context["post"] = post

        # Get related posts
        if post.categories:
            context["related_posts"] = post_service.get_posts(
                db, category_id=post.categories[0].id, limit=3
            )

        # Add parent column and sibling columns for sidebar navigation
        if column.parent_id:
            parent_column = db.query(SiteColumn).filter(
                SiteColumn.id == column.parent_id
            ).first()
            context["parent_column"] = parent_column

            # Get sibling columns (including current column)
            sibling_columns = site_service.get_child_columns(db, column.parent_id)
            context["sibling_columns"] = sibling_columns

        return templates.TemplateResponse("post_detail.html", context)

    else:
        raise HTTPException(status_code=404, detail="Invalid column type for detail page")


@router.post("/contact/submit")
async def submit_contact_form(
    request: Request,
    db: Session = Depends(get_db),
    name: str = Form(...),
    email: str = Form(...),
    phone: str = Form(""),
    subject: str = Form(...),
    message: str = Form(...),
):
    """
    Handle contact form submission with Pydantic validation
    """
    try:
        # Validate form data using Pydantic
        form_data = ContactFormRequest(
            name=name,
            email=email,
            phone=phone,
            subject=subject,
            message=message,
        )

        # Create new contact message
        contact_message = ContactMessage(
            name=form_data.name,
            contact_info=f"Email: {form_data.email}"
            + (f", Phone: {form_data.phone}" if form_data.phone else ""),
            message_text=f"Subject: {form_data.subject}\n\n{form_data.message}",
            source_page_url=request.headers.get("referer", "Direct submission"),
        )

        # Save to database
        db.add(contact_message)
        db.commit()
        db.refresh(contact_message)

        return JSONResponse(
            status_code=200,
            content={
                "success": True,
                "message": "Your message has been sent successfully. We'll get back to you soon!",
                "data": {"id": contact_message.id, "name": contact_message.name},
            },
        )

    except ValidationError as e:
        # Handle Pydantic validation errors
        error_messages = []
        for error in e.errors():
            field = error["loc"][-1]
            msg = error["msg"]
            error_messages.append(f"{field}: {msg}")

        return JSONResponse(
            status_code=400,
            content={
                "success": False,
                "message": "Validation failed: " + "; ".join(error_messages),
            },
        )

    except Exception as e:
        db.rollback()
        logger.error(f"Error submitting contact form: {str(e)}")
        return JSONResponse(
            status_code=500,
            content={
                "success": False,
                "message": "Sorry, there was an error sending your message. Please try again later.",
            },
        )

@router.post("/api/contact")
async def api_contact_form(
    request: Request,
    db: Session = Depends(get_db),
):
    """
    API endpoint for contact form (JSON POST)
    Used by the new homepage contact form
    """
    try:
        # Parse JSON body
        body = await request.json()

        # Validate required fields
        name = body.get("name", "").strip()
        email = body.get("email", "").strip()
        phone = body.get("phone", "").strip()
        interest = body.get("interest", "").strip()
        message = body.get("message", "").strip()

        if not name or not email or not interest or not message:
            return JSONResponse(
                status_code=400,
                content={
                    "success": False,
                    "message": "Please fill in all required fields",
                },
            )

        # Create new contact message
        contact_message = ContactMessage(
            name=name,
            contact_info=f"Email: {email}" + (f", Phone: {phone}" if phone else ""),
            message_text=f"Interested in: {interest}\n\n{message}",
            source_page_url=request.headers.get("referer", "Homepage contact form"),
        )

        # Save to database
        db.add(contact_message)
        db.commit()
        db.refresh(contact_message)

        logger.info(f"New contact form submission from {name} ({email}), interested in: {interest}")

        return JSONResponse(
            status_code=200,
            content={
                "success": True,
                "message": "Thank you for your message! We'll get back to you soon.",
                "data": {"id": contact_message.id, "name": contact_message.name},
            },
        )

    except Exception as e:
        db.rollback()
        logger.error(f"Error submitting contact form: {str(e)}")
        return JSONResponse(
            status_code=500,
            content={
                "success": False,
                "message": "Sorry, there was an error sending your message. Please try again later.",
            },
        )

@router.post("/guestbook/submit")
async def submit_guestbook_entry(
    request: Request,
    db: Session = Depends(get_db),
    name: str = Form(...),
    email: str = Form(...),
    message: str = Form(...),
):
    """
    Handle guestbook entry submission
    """
    try:
        from app.models.post import Post
        from datetime import datetime
        
        # Get guestbook column
        guestbook_column = site_service.get_column_by_slug(db, "guestbook")
        if not guestbook_column:
            return JSONResponse(
                status_code=500,
                content={
                    "success": False,
                    "message": "Guestbook not found",
                },
            )
        
        # Create new guestbook entry as a post (pending approval)
        new_entry = Post(
            column_id=guestbook_column.id,
            title=f"Message from {name}",
            slug=f"entry-{datetime.now().strftime('%Y%m%d-%H%M%S')}",
            summary=f"Message from {name} ({email})",
            content_html=f"<p>{message}</p>",
            status="published",
            is_recommended=False,
            is_approved=0,  # Pending approval - will show after shop owner replies
            published_at=datetime.now(),
        )
        
        # Save to database
        db.add(new_entry)
        db.commit()
        db.refresh(new_entry)
        
        logger.info(f"New guestbook entry from {name} ({email})")
        
        return JSONResponse(
            status_code=200,
            content={
                "success": True,
                "message": "Thank you for your message! It will appear after review by our team.",
                "data": {"id": new_entry.id, "name": name},
            },
        )
        
    except Exception as e:
        db.rollback()
        logger.error(f"Error submitting guestbook entry: {str(e)}")
        return JSONResponse(
            status_code=500,
            content={
                "success": False,
                "message": "Sorry, there was an error posting your message. Please try again later.",
            },
        )
